# 技术总结

## JVM

JVM是Java的运行时环境的一部分，通过JVM可以实现Java的跨平台运行。JVM通过通过将类文件编译成.class文件，解析其中的字节码，并执行对应平台对应的底层操作，屏蔽了各个平台的不同，从而实现了平台无关性。

JVM的内存模型包括几个关键的部分：堆、虚拟机栈、本地方法栈、Metaspace等等，除此之外，JVM也使用了一部分直接内存。

JVM的类加载机制被称为双亲委托，预定义的三种类加载器分别为BootstrapClassLoader(加载rt.jar)、ExtensionClassLoader(lib/ext)、SystemClassLoader(classpath)。通过同一个类加载器加载进来的类在JVM内部认为是相同的，但我们可以通过自定义的方式打破双亲委派机制，实现类的热加载。

JVM为开发者提供了垃圾回收机制，目前的垃圾收集器基本是基于分代理论，即大部分对象都是朝生夕死的。垃圾收集器基本可以分为年轻代收集器和老年代收集器，例如Serial、Serial Old、Parallel Scavenge、Parallel Old、老年代的CMS。除此之外还有G1GC、ZGC等等垃圾收集器。各款垃圾收集器有各自的适用场景，需要针对GC进行调优时，还需要根据具体情况进行分析（https://github.com/youdiannan/geekbang-java/commit/5473683114efed9b5d70ac06fd66bb40af9bb3ea）。

## NIO

Java常见的IO方式可以分为三种：BIO、NIO和AIO。其中BIO为同步阻塞IO，当发起IO时线程会阻塞直到结果返回；NIO则为同步非阻塞IO，通过在Selector注册事件，并通过select来获取相应事件准备就绪的连接进行处理，相比于BIO大大提高了线程的利用效率；AIO则是异步IO，连数据拷贝的操作都实现了非阻塞。

Java中的NIO应该属于IO多路复用的一种实现，通过select/epoll的方式来监听相应的连接。知名的网络编程框架Netty就是基于NIO进行的封装。

## 并发编程

由于摩尔定律的失效，CPU发展出了多核，为了更好的利用CPU，才进一步发展出了多线程。多线程的使用大大提高了CPU的使用效率，相比进程而言，其创建开销也相对较小，但同时也带来了一系列问题。例如，针对同一数据的处理在多线程环境下如果未能正确处理可能造成非预期的错误。线程的数目也并非越多越好，操作系统对线程进行调度也需要一定的资源。线程在用户态和内核态之间的切换也是比较重的操作，过程中需要对执行现场进行保存。

为了解决多线程的协同问题，Java提供了许多工具类，例如锁、信号量等等，个人认为其底层一定都依赖于操作系统提供的原子操作。除此之外，为了解决多线程环境下的数据处理问题，还有另一种方式，即线程封闭，让数据在线程内私有而非在线程间共享。

## Spring和ORM等框架

### Spring

Spring是一个DI框架，实现了IoC的思想。基于这样一个框架，我们可以在代码中将对象的创建和使用分离开来，减少了开发时的心智负担，也使得代码更加清晰。Spring Boot则封装了一些常用工具的创建过程，大大简化了开发过程。开发框架的选择，在一定程度上其实也影响了人员之间的协作方式。

### ORM框架

Java常见的ORM框架主要包括MyBatis、Hibernate。相对而言，MyBatis的ORM功能并不算很强大，底层仍然需要开发人员自己去编写SQL，但是相对的，开发人员自己对SQL的性能就有比较强的把控。而Hibernate，或者JPA，在开发上是比较简便的，相关数据库操作方法按照约定的命名习惯对方法进行命名即可，但相对的，对于底层SQL的把控就不足。

## MySQL 数据库和 SQL

数据库软件是对数据进行组织和管理的软件，各类软件都有各自的适用场景。例如适用于结构化数据和非结构化数据的数据库。MySQL属于关系型数据库的一种，支持多种存储引擎，目前比较常用的为InnoDB，支持事务的处理，索引的应用也大大提高了数据的检索效率。

就MySQL而言，其本身就有许多值得探讨的地方。例如InnoDB与MyISAM的区别、索引结构、页的划分、页的结构、Buffer Pool、锁、MVCC、查询优化等等。

## 分库分表

分库分表的出现个人认为主要是为了解决两个问题：一是数据量大时单库、单表的性能问题，二是解决过多信息集中于单库、单表带来的业务理解问题，需要进行拆分使得系统各部分更加清晰，更易于理解。

分库分表同时也带来了新的问题，即分布式事务问题，当数据分布在不同的机器上时，想要实现事务就需要一定的协调机制。常见的解决方案有2PC、3PC、TCC等等，ShardingSphere也集成了XA分布式事务，hmily提供了TCC的框架。

## RPC和微服务

RPC的出现是为了使得远程服务的调用像是在调用本地方法一样，屏蔽了通信的细节。而微服务的架构思想则是一步步走到今天，从单体应用，到SOA，再到微服务，逐步的在提高系统整体的可用性、性能、提升系统整体的吞吐量。

在微服务架构下，RPC+服务注册、发现机制，大大简化了服务间的调用，至少服务调用的细节对于应用开发者而言被屏蔽掉了。

一个RPC框架，除了应该包含序列化机制、通信协议之外，还应当提供服务的负载均衡、降级、熔断等等措施，充分适应微服务架构下服务的高可用、高性能的要求。

## 分布式缓存

分布式的架构本身就是为了保障系统的高可用、高性能，在分布式的场景下，单机的MySQL数据库由于BIO及磁盘IO的关系往往不能承受高并发，在这种情况下，为了应对高频的数据读写，缓存就被引入系统中来。Redis这一内存数据库就常常被用来作为分布式缓存。作为分布式的缓存，往往要求它具有高可用、高性能的特点。由于Redis本身是针对内存进行操作，同时又使用多线程来处理网络IO，其本身就能支持较高的并发量。除此之外，我们还可以通过Sentinel，或者是cluster方式部署Redis集群来提高分布式缓存整体的可用性。

## 分布式消息队列

在分布式的场景下，服务之间的调用关系变得十分复杂。有时一个服务需要通知其他多个服务进行操作，同时又不关心其他服务的处理情况，如果每次都显式的调用其他服务，那么代码就会变得非常臃肿，而且非常不易于维护。在这种情况下，分布式的消息队列就体现出了很大的优势。消息队列可以解耦各个服务，各个服务只需关注自己感兴趣的消息并进行处理，服务之间的调用关系一下简化了许多。除此之外，消息队列还具有削峰的作用，各个服务可以根据自己的能力消费消息，未能消费的就可以存在消息队列中等待后续消费，可以很好的应对大流量的场景。